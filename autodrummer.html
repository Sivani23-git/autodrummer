<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <title>Microphone Rhythm Test</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      background: linear-gradient(135deg, #667eea, #764ba2);
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      margin: 0;
    }
    .container {
      background: white;
      padding: 40px;
      border-radius: 20px;
      text-align: center;
      box-shadow: 0 20px 40px rgba(0,0,0,0.1);
      max-width: 600px;
      width: 90%;
    }
    h1 { color: #333; margin-bottom: 30px; }
    .mic-circle {
      width: 150px; height: 150px; border-radius: 50%;
      background: #667eea; display: flex; align-items: center;
      justify-content: center; margin: 20px auto; cursor: pointer;
      transition: all 0.3s ease; font-size: 4em;
    }
    .mic-circle:hover { transform: scale(1.1); }
    .mic-circle.recording { background: #dc3545; animation: pulse 1s infinite; }
    @keyframes pulse { 0%,100%{ transform: scale(1);} 50%{ transform: scale(1.2);} }
    .btn {
      background: #667eea; color: white; border: none; padding: 15px 30px;
      border-radius: 25px; font-size: 16px; cursor: pointer; margin: 10px;
      transition: all 0.3s ease;
    }
    .btn:hover { background: #5a67d8; transform: translateY(-2px); }
    .btn.stop { background: #dc3545; }
    .volume-bar { width: 100%; height: 30px; background: #e0e0e0; border-radius: 15px; margin: 20px 0; overflow: hidden; }
    .volume-fill { height: 100%; background: linear-gradient(90deg,#28a745,#ffc107,#dc3545); width: 0%; transition: width 0.1s ease; }
    .status { font-size: 18px; margin: 20px 0; padding: 15px; border-radius: 10px; }
    .status.info { background: #e3f2fd; color: #1565c0; }
    .status.success { background: #e8f5e9; color: #2e7d32; }
    .status.error { background: #ffebee; color: #c62828; }
    .debug { background: #f5f5f5; padding: 15px; border-radius: 10px; margin: 20px 0; font-family: monospace; text-align: left; max-height: 200px; overflow-y: auto; }
    .hidden { display: none; }
    canvas { width: 100%; height: 100px; background: #f8f9fa; border-radius: 10px; margin: 20px 0; display: block; }
    .tempo { font-size: 2em; font-weight: bold; color: #28a745; margin: 15px 0; }
    .beats { display:flex; justify-content:center; gap:10px; margin:20px 0; }
    .beat { width:40px; height:40px; border-radius:50%; background:#ccc; display:flex; align-items:center; justify-content:center; font-weight:bold; transition: all 0.3s ease; }
    .beat.active { background:#dc3545; color:white; transform: scale(1.3); }
  </style>
</head>
<body>
  <div class="container">
    <h1>ðŸŽ¤ Microphone Rhythm Test</h1>

    <div class="mic-circle" id="micCircle">ðŸŽ¤</div>

    <div>
      <button class="btn" id="startBtn">Start Microphone</button>
      <button class="btn stop hidden" id="stopBtn">Stop Microphone</button>
    </div>

    <div class="status info" id="status">Click "Start Microphone" to begin</div>

    <div class="volume-bar"><div class="volume-fill" id="volumeFill"></div></div>

    <div class="tempo" id="tempo">0 BPM</div>

    <div class="beats" id="beats">
      <div class="beat">1</div>
      <div class="beat">2</div>
      <div class="beat">3</div>
      <div class="beat">4</div>
    </div>

    <canvas id="canvas"></canvas>

    <div class="debug" id="debug">Debug info will appear here...</div>
  </div>

  <script>
    let audioContext = null;
    let mediaStream = null;
    let analyser = null;
    let microphone = null;
    let isRecording = false;
    let animationId = null;

    // Beat detection
    let lastBeatTime = 0;
    let beatIntervals = [];
    let currentBeat = 0;
    let detectedTempo = 0;

    // Rhythm
    let rhythmInterval = null;

    // DOM
    const startBtn = document.getElementById('startBtn');
    const stopBtn  = document.getElementById('stopBtn');
    const micCircle= document.getElementById('micCircle');
    const status   = document.getElementById('status');
    const volumeFill = document.getElementById('volumeFill');
    const debug    = document.getElementById('debug');
    const canvas   = document.getElementById('canvas');
    const tempo    = document.getElementById('tempo');
    const beats    = document.getElementById('beats');
    const ctx      = canvas.getContext && canvas.getContext('2d');

    function log(message) {
      console.log(message);
      debug.innerHTML += new Date().toLocaleTimeString() + ': ' + message + '<br>';
      debug.scrollTop = debug.scrollHeight;
    }

    function updateStatus(message, type = 'info') {
      status.textContent = message;
      status.className = 'status ' + type;
      log('STATUS: ' + message);
    }

    startBtn.addEventListener('click', startMicrophone);
    stopBtn.addEventListener('click', stopMicrophone);
    micCircle.addEventListener('click', () => { if (!isRecording) startMicrophone(); else stopMicrophone(); });

    async function startMicrophone() {
      try {
        log('Starting microphone...');
        updateStatus('Requesting microphone permission...', 'info');

        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        if (audioContext.state === 'suspended') await audioContext.resume();

        mediaStream = await navigator.mediaDevices.getUserMedia({ audio: true });
        microphone = audioContext.createMediaStreamSource(mediaStream);
        analyser = audioContext.createAnalyser();
        analyser.fftSize = 1024;
        analyser.smoothingTimeConstant = 0.3;
        microphone.connect(analyser);

        isRecording = true;
        startBtn.classList.add('hidden');
        stopBtn.classList.remove('hidden');
        micCircle.classList.add('recording');

        updateStatus('Microphone active! Make some noise!', 'success');

        lastBeatTime = 0;
        beatIntervals = [];
        detectedTempo = 0;
        tempo.textContent = '0 BPM';

        startAnalysis();
      } catch (error) {
        updateStatus('Mic error: ' + error.message, 'error');
      }
    }

    function stopMicrophone() {
      isRecording = false;
      if (animationId) cancelAnimationFrame(animationId);
      if (mediaStream) { mediaStream.getTracks().forEach(t => t.stop()); }
      if (microphone) microphone.disconnect();
      analyser = null;
      if (audioContext) { audioContext.close(); audioContext = null; }
      stopRhythm();

      startBtn.classList.remove('hidden');
      stopBtn.classList.add('hidden');
      micCircle.classList.remove('recording');
      volumeFill.style.width = '0%';
      tempo.textContent = '0 BPM';
      beatIntervals = [];
      lastBeatTime = 0;
      currentBeat = 0;

      updateStatus('Microphone stopped', 'info');
    }

    function startAnalysis() {
      if (!analyser) return;
      const dataArray = new Uint8Array(analyser.frequencyBinCount);
      const timeArray = new Uint8Array(analyser.fftSize);

      function analyze() {
        if (!isRecording || !analyser) return;

        analyser.getByteFrequencyData(dataArray);
        analyser.getByteTimeDomainData(timeArray);

        // volume RMS
        let sum = 0;
        for (let i = 0; i < timeArray.length; i++) {
          const sample = (timeArray[i] - 128) / 128;
          sum += sample * sample;
        }
        const volume = Math.sqrt(sum / timeArray.length);
        const volumePercent = Math.min(100, volume * 300);
        volumeFill.style.width = volumePercent + '%';

        detectBeat(volume);
        drawWaveform(dataArray, timeArray);

        animationId = requestAnimationFrame(analyze);
      }
      analyze();
    }

    function detectBeat(volume) {
      const threshold = 0.05;
      const currentTime = Date.now();
      if (volume > threshold) {
        const timeSinceLastBeat = currentTime - lastBeatTime;
        if (timeSinceLastBeat > 300) {
          if (lastBeatTime > 0) {
            const interval = timeSinceLastBeat / 1000;
            beatIntervals.push(interval);
            if (beatIntervals.length > 8) beatIntervals = beatIntervals.slice(-8);
            if (beatIntervals.length >= 3) updateTempo();
          }
          lastBeatTime = currentTime;
          animateBeat();
        }
      }
    }

    function updateTempo() {
      const sorted = [...beatIntervals].sort((a,b)=>a-b);
      const median = sorted[Math.floor(sorted.length/2)];
      const newTempo = Math.round(60/median);
      detectedTempo = Math.max(40, Math.min(240, newTempo));
      tempo.textContent = detectedTempo + ' BPM';
      log('Tempo: ' + detectedTempo);
      startRhythm(detectedTempo);
    }

    function animateBeat() {
      const beatElements = beats.querySelectorAll('.beat');
      beatElements.forEach(b => b.classList.remove('active'));
      const beatIndex = currentBeat % beatElements.length;
      beatElements[beatIndex].classList.add('active');
      setTimeout(() => beatElements[beatIndex].classList.remove('active'), 200);
      currentBeat++;
    }

    function drawWaveform(freqArray, timeArray) {
      if (!ctx) return;
      const dpr = window.devicePixelRatio || 1;
      const displayWidth = canvas.offsetWidth;
      const displayHeight = canvas.offsetHeight;
      canvas.width = Math.floor(displayWidth * dpr);
      canvas.height = Math.floor(displayHeight * dpr);
      ctx.scale(dpr, dpr);
      ctx.clearRect(0, 0, displayWidth, displayHeight);
      const barCount = Math.floor(freqArray.length / 2);
      const barWidth = displayWidth / barCount;
      let x = 0;
      for (let i=0; i<barCount; i++) {
        const val = freqArray[i];
        const barHeight = (val/255)*displayHeight*0.8;
        const hue = Math.floor((i/barCount)*240);
        ctx.fillStyle = 'hsl('+hue+',70%,50%)';
        ctx.fillRect(x, displayHeight-barHeight, barWidth-1, barHeight);
        x += barWidth;
      }
      ctx.beginPath();
      const step = Math.max(1, Math.floor(timeArray.length/displayWidth));
      const mid = displayHeight/2;
      ctx.lineWidth = 1;
      for (let i=0, px=0; i<timeArray.length; i+=step, px++) {
        const sample = (timeArray[i]-128)/128;
        const y = mid + sample*mid*0.9;
        if (px===0) ctx.moveTo(px,y); else ctx.lineTo(px,y);
      }
      ctx.strokeStyle='rgba(0,0,0,0.2)';
      ctx.stroke();
      ctx.setTransform(1,0,0,1,0,0);
    }

    // -------- Rhythm Generator ----------
    function startRhythm(bpm) {
      stopRhythm();
      if (!audioContext) return;
      const intervalMs = (60/bpm)*1000;
      let beatCount = 0;
      rhythmInterval = setInterval(() => {
        playBeat(beatCount);
        beatCount++;
      }, intervalMs);
    }

    function stopRhythm() {
      if (rhythmInterval) { clearInterval(rhythmInterval); rhythmInterval = null; }
    }

    function playBeat(beat) {
      if (!audioContext) return;
      if (beat % 4 === 0) playKick();
      else if (beat % 4 === 2) playSnare();
      playHiHat();
    }

    function playKick() {
      const osc = audioContext.createOscillator();
      const gain = audioContext.createGain();
      osc.type='sine';
      osc.frequency.setValueAtTime(150,audioContext.currentTime);
      osc.frequency.exponentialRampToValueAtTime(50,audioContext.currentTime+0.5);
      gain.gain.setValueAtTime(1,audioContext.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.001,audioContext.currentTime+0.5);
      osc.connect(gain).connect(audioContext.destination);
      osc.start(); osc.stop(audioContext.currentTime+0.5);
    }

    function playSnare() {
      const bufferSize=audioContext.sampleRate*0.2;
      const buffer=audioContext.createBuffer(1,bufferSize,audioContext.sampleRate);
      const data=buffer.getChannelData(0);
      for(let i=0;i<bufferSize;i++){ data[i]=Math.random()*2-1; }
      const noise=audioContext.createBufferSource(); noise.buffer=buffer;
      const filter=audioContext.createBiquadFilter(); filter.type='highpass'; filter.frequency.value=1000;
      const gain=audioContext.createGain();
      gain.gain.setValueAtTime(1,audioContext.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.01,audioContext.currentTime+0.2);
      noise.connect(filter).connect(gain).connect(audioContext.destination);
      noise.start(); noise.stop(audioContext.currentTime+0.2);
    }

    function playHiHat() {
      const bufferSize=audioContext.sampleRate*0.05;
      const buffer=audioContext.createBuffer(1,bufferSize,audioContext.sampleRate);
      const data=buffer.getChannelData(0);
      for(let i=0;i<bufferSize;i++){ data[i]=Math.random()*2-1; }
      const noise=audioContext.createBufferSource(); noise.buffer=buffer;
      const filter=audioContext.createBiquadFilter(); filter.type='highpass'; filter.frequency.value=5000;
      const gain=audioContext.createGain();
      gain.gain.setValueAtTime(0.5,audioContext.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.01,audioContext.currentTime+0.05);
      noise.connect(filter).connect(gain).connect(audioContext.destination);
      noise.start(); noise.stop(audioContext.currentTime+0.05);
    }

    log('Page loaded, ready to test microphone rhythm');
  </script>
</body>
</html>
